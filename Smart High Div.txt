"""
Copyright Chris Short 2017
Use is unauthorized without written permission

TODO
- in/out of market indicators
- double-check order execution logic
- pick longs via smartscreen custom factor
- pick shorts

Ranking algorithm notes:
    - screen for low P/E, high book val/share
    - consider brand favorability factor
    - use smart screen point-based ranks
    - rank longs and shorts separately

Calculate long and short buckets:
    - use top X% of long/short ranks
    - optimize weights to minimize covariance
        - https://www.quantopian.com/posts/quantopian-lecture-series-the-good-the-bad-and-the-correlated

- rebalance monthly
- Use same in/out indicators - unempl + SPY momentum
- when in the market, buy n% long, m% short
- when out of market, short 50% short bucket, 50% SPY
- Experiment:  Short only stocks in one sector e.g. retail

"""
from quantopian.algorithm import attach_pipeline, pipeline_output
from quantopian.pipeline import Pipeline, CustomFactor
from quantopian.pipeline.data import morningstar
from quantopian.pipeline.data.quandl import fred_unrate
from quantopian.pipeline.filters.morningstar import Q1500US
from quantopian.pipeline.data.builtin import USEquityPricing
 
# Constants
LoggingEnabled = False
UTILITIES_SECTOR = 207
REBALANCE_DAY = 5
NUM_LONG = 7
NUM_SHORT = 7

class UnemplData(object):
    def __init__(self, pastData):
        self.pastData = pastData
    
    def cache_latest(self, currUnempl):
        self.pastData.append(currUnempl)
    
    def is_favorable(self):
        current = self.pastData[-1]
        pastAvg = (self.pastData[-4] + self.pastData[-3] + self.pastData[-2]) / 3
        return current > pastAvg

class CurrUnemplFactor(CustomFactor):
    window_length = 1
    inputs = [fred_unrate.value]
    
    def compute(self, today, assets, out, unempl):
        out[:] = unempl

def initialize(context):
    # Initialize context variables
    context.long_bucket = []
    context.short_bucket = []
    context.rebalanceDue = False
    context.unemplData = UnemplData(build_past_data())
    
    # Rebalance once per month
    schedule_function(set_rebalance_due,
                      date_rules.month_start(days_offset=REBALANCE_DAY-2),
                      time_rules.market_close())
    
    # Record tracking variables at the end of each day.
    schedule_function(record_vars, date_rules.every_day(), time_rules.market_close())
    
    # Try to execute orders every day to cover unexecuted orders
    schedule_function(execute_orders,
                      date_rules.every_day(),
                      time_rules.market_open(minutes=5))
    
    # Set up pipeline
    pipe = Pipeline()  
    attach_pipeline(pipe, name='pipe')
    build_pipeline(pipe)
    
def build_pipeline(pipe):
    universe_filter = Q1500US()
    
    # Screen for no utilities and minimum volume
    sector_code = morningstar.asset_classification.morningstar_sector_code.latest
    sector_filter = (sector_code != UTILITIES_SECTOR)
    
    # Screens
    div_yld = morningstar.valuation_ratios.dividend_yield.latest
    high_div_filter = (div_yld > .04)
    no_div_filter = ~(div_yld > 0.0)
    pipe.add(div_yld, 'div_yld')
    
    # Track financial metrics
    pipe.add(morningstar.operation_ratios.long_term_debt_equity_ratio.latest, 'debtToEquity')
    pipe.add(morningstar.operation_ratios.roe.latest, 'roe')
    pipe.add(USEquityPricing.close.latest, 'close')
    pipe.add(morningstar.operation_ratios.ebitda_margin.latest, 'ebit_mgn')
    pipe.add(CurrUnemplFactor(), 'unempl')
    
    pipe.set_screen(universe_filter &
                    sector_filter &
                    (high_div_filter | no_div_filter))
    return pipe

def set_rebalance_due(context, data):
    context.rebalanceDue = True

def before_trading_start(context, data):
    if not context.rebalanceDue:
        return
    context.rebalanceDue = False
    log.info("REBALANCING")
    
    #TBD: Filter pipeline output to security list
    pipe = pipeline_output('pipe')
    
    # Recalculate favorability
    context.unemplData.cache_latest(pipe['unempl'][0])
    
    # Rebalance
    context.long_bucket = get_long_bucket(pipe)
    context.short_bucket = get_short_bucket(pipe)

def get_long_bucket(pipe):
    # TODO eventually, pick long and short buckets using smart-screeer logic
    return pipe[pipe.div_yld > 0.04].iloc[:NUM_LONG].index[:NUM_LONG]
    
def get_short_bucket(pipe):
    # TODO eventually, pick long and short buckets using smart-screeer logic
    return pipe[
        ~(pipe.div_yld > 0.0)].iloc[:NUM_SHORT].index[:NUM_SHORT]

def execute_orders(context,data):
    # Cover stocks no longer in lists
    for stock in context.portfolio.positions.iterkeys():  
        if stock not in context.long_bucket and \
            stock not in context.short_bucket and \
            data.can_trade(stock):
                order_target(stock, 0)
    
    # Buy longs
    for stock in context.long_bucket:
        if data.can_trade(stock):
            order_target_percent(stock, (1.0 / NUM_LONG))
    
    # Sell shorts
    for stock in context.short_bucket:
        if data.can_trade(stock):
            order_target_percent(stock, (-1.0 / NUM_SHORT))

def record_vars(context, data):
    if not LoggingEnabled:
        return
    
    # Plot variables at the end of each day.
    long_count = 0
    short_count = 0
    leverage = context.account.leverage
    
    log_str = "holding: "
    for position in context.portfolio.positions.itervalues():
        if position.amount > 0:
            long_count += 1
            log_str += position.sid.symbol + ", "
        if position.amount < 0:
            short_count += 1
            log_str += position.sid.symbol + "(short), "
    
    # Raise an alert if short_count or leverage out of contest range
    if short_count == 0:
        short_count = 99
    if leverage > 3:
        leverage = 99
    
    # Plot the counts
    #record(num_long=long_count, num_short=short_count, currUnempl=currUnempl, pastUnempl=pastUnempl, leverage=leverage)
    record(num_long=long_count, short_count=short_count, leverage=leverage)
    log.info(log_str)

def build_past_data():
    unempl_list = [
        5.3, 5.2, 5.2, 5.1, 4.9, 5, 4.9, 4.8, 4.9, 4.7, 4.6, 4.7,
        4.6, 4.6, 4.7, 4.3, 4.4, 4.5, 4.5, 4.5, 4.6, 4.5, 4.4, 4.4,
        4.3, 4.4, 4.2, 4.3, 4.2, 4.3, 4.3, 4.2, 4.2, 4.1, 4.1, 4,
        4, 4.1, 4, 3.8, 4, 4, 4, 4.1, 3.9, 3.9, 3.9, 3.9, 4.2, 4.2,
        4.3, 4.4, 4.3, 4.5, 4.6, 4.9, 5, 5.3, 5.5, 5.7, 5.7, 5.7,
        5.7, 5.9, 5.8, 5.8, 5.8, 5.7, 5.7, 5.7, 5.9, 6, 5.8, 5.9,
        5.9, 6, 6.1, 6.3, 6.2, 6.1, 6.1, 6, 5.8, 5.7, 5.7, 5.6, 5.8,
        5.6, 5.6, 5.6, 5.5, 5.4, 5.4, 5.5, 5.4, 5.4, 5.3, 5.4, 5.2,
        5.2, 5.1, 5, 5, 4.9, 5, 5, 5, 4.9, 4.7, 4.8, 4.7, 4.7, 4.6,
        4.6, 4.7, 4.7, 4.5, 4.4, 4.5, 4.4, 4.6, 4.5, 4.4, 4.5, 4.4,
        4.6, 4.7, 4.6, 4.7, 4.7, 4.7, 5, 5, 4.9, 5.1, 5, 5.4, 5.6,
        5.8, 6.1, 6.1, 6.5, 6.8, 7.3, 7.8, 8.3, 8.7, 9, 9.4, 9.5,
        9.5, 9.6, 9.8, 10, 9.9, 9.9, 9.8, 9.8, 9.9, 9.9, 9.6, 9.4,
        9.4, 9.5, 9.5, 9.4, 9.8, 9.3, 9.1, 9, 9, 9.1, 9, 9.1, 9, 9,
        9, 8.8, 8.6, 8.5, 8.3, 8.3, 8.2, 8.2, 8.2, 8.2, 8.2, 8.1,
        7.8, 7.8, 7.7, 7.9, 8, 7.7, 7.5, 7.6, 7.5, 7.5, 7.3, 7.3,
        7.2, 7.2, 6.9, 6.7, 6.6, 6.7, 6.7, 6.2, 6.3, 6.1, 6.2, 6.2,
        5.9, 5.7, 5.8, 5.6, 5.7, 5.5, 5.4, 5.4, 5.5, 5.3, 5.2, 5.1,
        5, 5, 5, 5, 4.9, 4.9, 5.0, 5.0, 4.7, 4.9, 4.9, 4.9, 4.9, 
        4.8, 4.6, 4.7, 4.8]
    
    # Strip future values
    now = get_datetime()
    monthOffset = ((now.year - 1997) * 12) + now.month
    unempl_list = unempl_list[:monthOffset]
    
    return unempl_list