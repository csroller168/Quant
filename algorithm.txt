"""
Copyright Chris Short 2016
Use is unauthorized without written permission

    # TODO
    - Contest eligibility
        - Implement new short strategy to reduce beta (see lectures possibly)
        - look into using base_universe per this example:  https://www.quantopian.com/posts/optimize-api-now-available-in-algorithms
     
     Lower priority:
     - adjust SPY short% during total pullout - optimize beta and drawdown
     - consider vary SPY short % with real time beta
     - filter by 4% 5 yr avg. div yld
         - or try to use dividend yield I'm currently getting, and figure out how to get selected past values with a limited window (maybe hacking with some way to set the current datetime, or some way to call calculate() with amended today value...)
            def compute(self, today, assets, out, close):
                today = today - 1 year
                # repeat above for 4 custom factors for each year back
                out[:] = something...
     - Consider change momentum indicator to mavg(14) <= mavg(50)
     - Consider reduce leverage if one indicator says to sell but other doesn't

"""
from quantopian.algorithm import attach_pipeline, pipeline_output
from quantopian.pipeline import Pipeline, CustomFactor
from quantopian.pipeline.classifiers.morningstar import Sector
from quantopian.pipeline.data import morningstar
from quantopian.pipeline.data.quandl import fred_unrate
import pandas as pd
import numpy as np
 
UTILITIES_SECTOR = 207

class CurrUnemplFactor(CustomFactor):
    window_length = 1
    inputs = [fred_unrate.value]
    
    def compute(sef, today, assets, out, unempl):
        out[:] = unempl

def initialize(context):
    """
    Called once at the start of the algorithm.
    """   
    # Rebalance monthly after unemployment rate announced,
    # 1 minute after market open.
    schedule_function(my_rebalance,
                      date_rules.month_start(days_offset=6),
                      time_rules.market_open(minutes=1))
     
    # Record tracking variables at the end of each day.
    schedule_function(my_record_vars, date_rules.every_day(), time_rules.market_close())
    
    # Make a single trade at the launch of the algo
    context.algo_started = False
    schedule_function(my_rebalance_once,
                      date_rules.every_day(),
                      time_rules.market_open(minutes=1))
    
    # Try to execute every day to cover unexecuted orders
    schedule_function(execute_orders,
                      date_rules.every_day(),
                      time_rules.market_open(minutes=5))
    
    # Initialize unemployment rate variables
    context.unempl = build_unempl_collection()
    context.unemplSet = False
    
    # Set up long pipeline
    pipe = Pipeline()  
    attach_pipeline(pipe, name='my_pipeline')
    build_pipeline(pipe)

def build_pipeline(pipe):
    # Add employment data
    pipe.add(CurrUnemplFactor(), 'unempl')
    
    # Screen for no utilities
    sector_code = morningstar.asset_classification.morningstar_sector_code.latest
    sector_filter = (sector_code != UTILITIES_SECTOR)
    
    # Screen for high current dividend yield
    div_yld = morningstar.valuation_ratios.dividend_yield.latest
    pipe.add(div_yld, 'div_yld')
    div_filter = (div_yld > .04)
    
    # Screen for approximation of S&P 500
    mkt_cap = morningstar.valuation.market_cap.latest
    country_id = morningstar.company_reference.country_id.latest
    exchange_id = morningstar.company_reference.primary_exchange_id.latest
    pipe.add(mkt_cap, 'mkt_cap')
    pipe.add(country_id, 'country_id')
    pipe.add(exchange_id, 'exchange_id')
    mktCap_filter = (mkt_cap > 4000000000)
    
    # Screen for non-negative debt-equity ratio
    debtToEquity = morningstar.operation_ratios.long_term_debt_equity_ratio.latest
    pipe.add(debtToEquity, 'debtToEquity')
    
    pipe.set_screen(sector_filter & div_filter & mktCap_filter)

def before_trading_start(context, data):
    """
    Filter pipeline output to security list
    NOTE:  I'm doing this here since it takes a while and this apparently has a longer timeout than my_rebalance()
    """
    my_pipeline = pipeline_output('my_pipeline')
    
    # Cache unemployment data once per month
    if get_datetime().day < 6:
        context.unemplSet = False
    if get_datetime().day >= 6 and context.unemplSet == False:
        context.unempl.append(my_pipeline['unempl'][0])
        context.unemplSet = True
    
    # approixmate S&P 500
    snp_stocks = my_pipeline[
        (my_pipeline.country_id == "USA") & 
        ((my_pipeline.exchange_id == "NAS") | 
         (my_pipeline.exchange_id == "NYSE")) & 
        (data.can_trade(my_pipeline.index))].sort_values(by='mkt_cap', ascending=False).iloc[:50]
    
    # Get top 7 by debt-equity ratio
    context.security_list = snp_stocks.sort_values(by='debtToEquity',ascending=True).index[:7]

def is_unempl_unfavorable(unempl):
    currUnempl = unempl[-1]
    pastUnempl = (unempl[-4] + unempl[-3] + unempl[-2]) / 3
    unemplUnfavorable = currUnempl > pastUnempl
    return unemplUnfavorable

def my_rebalance(context,data):
    
    # Calculate unemployment indicator
    context.unemplUnfavorable = is_unempl_unfavorable(context.unempl)
    
    # Calculate momentum indicator
    spy = symbol('SPY')
    mavgShort = data.history(spy, 'price', 50, '1d').mean()
    mavgLong = data.history(spy, 'price', 200, '1d').mean()
    context.momentumUnfavorable = mavgShort <= mavgLong

def execute_orders(context,data):
    sell_everything = False
    # Sell everything if indicators unfavorable
    if context.momentumUnfavorable and context.unemplUnfavorable:
        for stock in context.portfolio.positions.iterkeys():
            order_target(stock, 0)
        sell_everything = True
    
    # Short SPY according to indicators
    if context.momentumUnfavorable and context.unemplUnfavorable:
        order_target_percent(symbol('SPY'), -0.8)
    elif context.momentumUnfavorable or context.unemplUnfavorable:
        order_target_percent(symbol('SPY'), -0.5)
    else:
        order_target_percent(symbol('SPY'), -0.3)
    
    if sell_everything:
        return
    
    for stock in context.portfolio.positions.iterkeys():  
        if stock not in context.security_list and stock.symbol != 'SPY':  
            order_target(stock, 0)
    
    long_weight = 1.8 / float(len(context.security_list))  
    for long_stock in context.security_list:
        order_target_percent(long_stock, long_weight)

def my_rebalance_once(context, data):
    if not context.algo_started:
        context.algo_started = True
        my_rebalance(context,data)
 
def my_record_vars(context, data):
    """
    Plot variables at the end of each day.
    """
    long_count = 0
    short_count = 0
    leverage = context.account.leverage
    unempl = context.unempl
    currUnempl = unempl[-1]
    pastUnempl = (unempl[-4] + unempl[-3] + unempl[-2]) / 3
    if pastUnempl > 10:
        pastUnempl = 0
    
    log_str = "holding: "
    for position in context.portfolio.positions.itervalues():
        if position.amount > 0:
            long_count += 1
            log_str += position.sid.symbol + ", "
        if position.amount < 0:
            short_count += 1
            log_str += position.sid.symbol + "(short), "
    
    # Plot the counts
    record(num_long=long_count, num_short=short_count, currUnempl=currUnempl, pastUnempl=pastUnempl, leverage=leverage)
    log.info(log_str)

def build_unempl_collection():
    unempl_list = [
        5.3, 5.2, 5.2, 5.1, 4.9, 5, 4.9, 4.8, 4.9, 4.7, 4.6, 4.7,
        4.6, 4.6, 4.7, 4.3, 4.4, 4.5, 4.5, 4.5, 4.6, 4.5, 4.4, 4.4,
        4.3, 4.4, 4.2, 4.3, 4.2, 4.3, 4.3, 4.2, 4.2, 4.1, 4.1, 4,
        4, 4.1, 4, 3.8, 4, 4, 4, 4.1, 3.9, 3.9, 3.9, 3.9, 4.2, 4.2,
        4.3, 4.4, 4.3, 4.5, 4.6, 4.9, 5, 5.3, 5.5, 5.7, 5.7, 5.7,
        5.7, 5.9, 5.8, 5.8, 5.8, 5.7, 5.7, 5.7, 5.9, 6, 5.8, 5.9,
        5.9, 6, 6.1, 6.3, 6.2, 6.1, 6.1, 6, 5.8, 5.7, 5.7, 5.6, 5.8,
        5.6, 5.6, 5.6, 5.5, 5.4, 5.4, 5.5, 5.4, 5.4, 5.3, 5.4, 5.2,
        5.2, 5.1, 5, 5, 4.9, 5, 5, 5, 4.9, 4.7, 4.8, 4.7, 4.7, 4.6,
        4.6, 4.7, 4.7, 4.5, 4.4, 4.5, 4.4, 4.6, 4.5, 4.4, 4.5, 4.4,
        4.6, 4.7, 4.6, 4.7, 4.7, 4.7, 5, 5, 4.9, 5.1, 5, 5.4, 5.6,
        5.8, 6.1, 6.1, 6.5, 6.8, 7.3, 7.8, 8.3, 8.7, 9, 9.4, 9.5,
        9.5, 9.6, 9.8, 10, 9.9, 9.9, 9.8, 9.8, 9.9, 9.9, 9.6, 9.4,
        9.4, 9.5, 9.5, 9.4, 9.8, 9.3, 9.1, 9, 9, 9.1, 9, 9.1, 9, 9,
        9, 8.8, 8.6, 8.5, 8.3, 8.3, 8.2, 8.2, 8.2, 8.2, 8.2, 8.1,
        7.8, 7.8, 7.7, 7.9, 8, 7.7, 7.5, 7.6, 7.5, 7.5, 7.3, 7.3,
        7.3, 7.2, 6.9, 6.7, 6.6, 6.7, 6.7, 6.2, 6.2, 6.1, 6.2, 6.2,
        6, 5.7, 5.8, 5.6, 5.7, 5.5, 5.5, 5.4, 5.5, 5.3, 5.3, 5.1,
        5.1, 5, 5, 5, 4.9, 4.9, 5.0, 5.0, 4.7, 4.9, 4.9, 4.9, 5.0, 
        4.9, 4.6]
    
    # Strip future values
    now = get_datetime()
    monthOffset = ((now.year - 1997) * 12) + now.month - 1
    unempl_list = unempl_list[:monthOffset]
    
    return unempl_list

