"""
Copyright Chris Short 2016
Use is unauthorized without written permission

    # TODO
     1. filter by 4% 5 yr avg. div yld
        Either use custom factor (see https://www.quantopian.com/posts/fundamental-history-based-algo#5616e27ea8e03d7580000155)
        ... or, query quandl for each stock
            (if cant fetch all stock div ylds in time, short circuit after 7, or perform fetching in separately scheduled func)
        ... or, see what other free quantopian providers
     2. Consider change momentum indicator to mavg(14) <= mavg(50)
     3. Filter by actual S&P 500 (prepare my own dataset and use fetcher)
     4. Graph realized returns on sale

"""
from quantopian.algorithm import attach_pipeline, pipeline_output
from quantopian.pipeline import Pipeline
from quantopian.pipeline.classifiers.morningstar import Sector
from quantopian.pipeline import CustomFactor
from quantopian.pipeline.data import morningstar
from quantopian.pipeline.data.quandl import fred_unrate
import pandas as pd
 
UTILITIES_SECTOR = 207

# For fetcher
def pre_func(df):
    df = df.iloc[::-1]
    unemp = df['VALUE']
    df['past_unemp'] = (pd.rolling_mean(unemp, 4) * 4 - unemp) / 3
    df = df.bfill()
    return df

def post_func(df):
    df = df.rename(columns={'VALUE': 'price'})
    df = df.ffill()
    return df

def initialize(context):
    """
    Called once at the start of the algorithm.
    """   
    # Rebalance monthly after unemployment rate announced,
    # 1 minute after market open.
    schedule_function(my_rebalance,
                      date_rules.month_start(days_offset=6),
                      time_rules.market_open(minutes=1))
     
    # Record tracking variables at the end of each day.
    schedule_function(my_record_vars, date_rules.every_day(), time_rules.market_close())
    
    # Fetch unemployment rate data
    fetch_csv('http://www.quandl.com/api/v1/datasets/FRED/UNRATE.csv?trim_start=2007-12-03', date_column='DATE', symbol='unemp', usecols=['VALUE'], pre_func=pre_func, post_func=post_func, date_format='%Y-%m-%d')
    
    # Set up pipeline
    pipe = Pipeline()  
    attach_pipeline(pipe, name='my_pipeline')
    #pipe.add(CurrUnemplFactor(), 'curr_unempl')
    
    # Screen for no utilities
    sector_code = morningstar.asset_classification.morningstar_sector_code.latest
    sector_filter = (sector_code != UTILITIES_SECTOR)
    
    # Screen for high current dividend yield
    div_yld = morningstar.valuation_ratios.dividend_yield.latest
    pipe.add(div_yld, 'div_yld')
    div_filter = (div_yld > .04)
    
    # Screen for approximation of S&P 500
    mkt_cap = morningstar.valuation.market_cap.latest
    country_id = morningstar.company_reference.country_id.latest
    exchange_id = morningstar.company_reference.primary_exchange_id.latest
    pipe.add(mkt_cap, 'mkt_cap')
    pipe.add(country_id, 'country_id')
    pipe.add(exchange_id, 'exchange_id')
    mktCap_filter = (mkt_cap > 4000000000)
    
    # Screen for non-negative debt-equity ratio
    debtToEquity = morningstar.operation_ratios.long_term_debt_equity_ratio.latest
    pipe.add(debtToEquity, 'debtToEquity')
    
    pipe.set_screen(sector_filter & div_filter & mktCap_filter)

def before_trading_start(context, data):  
    log.info(get_datetime())
    pass
 
def my_rebalance(context,data):  
    """
    Filter pipeline output to security list
    """
    my_pipeline = pipeline_output('my_pipeline')
    
    # Calculate unemployment indicator
    currUnempl = data['unemp'].price
    pastUnempl = data['unemp'].past_unemp
    unemplUnfavorable = currUnempl > pastUnempl
    
    # Calculate momentum indicator
    spy = symbol('SPY')
    mavgShort = data.history(spy, 'price', 50, '1d').mean()
    mavgLong = data.history(spy, 'price', 200, '1d').mean()
    momentumUnfavorable = mavgShort <= mavgLong
    
    # Sell everything if indicators unfavorable
    if momentumUnfavorable and unemplUnfavorable:
        for stock in context.portfolio.positions.iterkeys():
            order_target(stock, 0)
        return
    
    # approixmate S&P 500
    snp_stocks = my_pipeline[
        (my_pipeline.country_id == "USA") & 
        ((my_pipeline.exchange_id == "NAS") | 
         (my_pipeline.exchange_id == "NYSE")) & 
        (data.can_trade(my_pipeline.index))].sort_values(by='mkt_cap', ascending=False).iloc[:50]
    
    # Get top 7 by debt-equity ratio
    context.security_list = snp_stocks.sort_values(by='debtToEquity',ascending=True).index[:7]
    
    """
    Execute orders according to our schedule_function() timing. 
    """
    for stock in context.portfolio.positions.iterkeys():  
        if stock not in context.security_list:  
            order_target(stock, 0)
    
    long_weight = 2.0 / float(len(context.security_list))  
    for long_stock in context.security_list:
        order_target_percent(long_stock, long_weight)    
    pass
 
def my_record_vars(context, data):
    """
    Plot variables at the end of each day.
    """
    long_count = 0
    short_count = 0
    cash = context.portfolio.cash
    
    log_str = "holding: "
    for position in context.portfolio.positions.itervalues():
        if position.amount > 0:
            long_count += 1
            log_str += position.sid.symbol + ", "
        if position.amount < 0:
            short_count += 1
            log_str += position.sid.symbol + "(short), "

    # Plot the counts
    record(num_long=long_count, num_short=short_count, cash=cash)
    log.info(log_str)
    pass
 
def handle_data(context,data):
    """
    Called every minute.
    TBD: Delete?
    """
    pass
