"""
Copyright Chris Short 2016
Use is unauthorized without written permission

    # TODO
    # 1. filter S&P 500 via static list (this can be done last for v1 or put off until v2) - fetcher
    # 2. screen no utilities sector
    # 3. screen top 7 by any easy factor
    # 4. (future) filter by 4% current and 5 yr avg. div yld (possibly see morningstar fundamentals)
    # 5. (future) screen top 7 by debt/equity ratio (see morningstar fundamentals)


"""
from quantopian.algorithm import attach_pipeline, pipeline_output
from quantopian.pipeline import Pipeline
from quantopian.pipeline.data.builtin import USEquityPricing
from quantopian.pipeline.factors import AverageDollarVolume
from quantopian.pipeline.classifiers.morningstar import Sector
from quantopian.pipeline.data import morningstar  
from quantopian.pipeline import CustomFactor  
 
UTILITIES_SECTOR = 207

class MarketCap(CustomFactor):  
    # Pre-declare inputs and window_length  
    inputs = [USEquityPricing.close, morningstar.valuation.shares_outstanding]  
    window_length = 1

    # Compute market cap value  
    def compute(self, today, assets, out, close, shares):  
        out[:] = close[-1] * shares[-1]
    
def initialize(context):
    """
    Called once at the start of the algorithm.
    """   
    # Rebalance monthly after unemployment rate announced,
    # 1 minute after market open.
    schedule_function(my_rebalance,
                      date_rules.month_start(days_offset=6),
                      time_rules.market_open(minutes=1))
     
    # Record tracking variables at the end of each day.
    schedule_function(my_record_vars, date_rules.every_day(), time_rules.market_close())
     
    pipe = Pipeline()  
    attach_pipeline(pipe, name='my_pipeline')  
    #***Trying to filter out stocks with a market cap below $50 mill  
    mkt_cap = MarketCap()  
    mkt_cap_price = mkt_cap > 50000000  
    pipe.set_screen(mkt_cap_price)  
    #***I am trying to get these fundamentals from the last year.  
    ent_val = morningstar.valuation.enterprise_value.latest

    ebt = morningstar.income_statement.ebit.latest

    at = morningstar.operation_ratios.assets_turnover.latest  
    earnings_yield = ebt/ent_val  
    #I want to add the earnings_yield + roc and find 30 stocks with the highest combination of these two fundamentals.  
    pos = earnings_yield + at

    pos_rank = pos.rank(ascending=False)  
    pipe.add(pos_rank, 'pos_rank')
    
    context.my_leverage = 1
         
def make_pipeline():

    
    # Create a dollar volume factor.
    dollar_volume = AverageDollarVolume(window_length=1)
 
    # Pick the top 1% of stocks ranked by dollar volume.
    high_dollar_volume = dollar_volume.percentile_between(99, 100)
     
    pipe = Pipeline(
        screen = high_dollar_volume,
        columns = {
            'dollar_volume': dollar_volume
        }
    )
    return pipe
 
def before_trading_start(context, data):  
    my_pipeline = pipeline_output('my_pipeline')  
    log.info((my_pipeline.sort('pos_rank')).head(30))  
    context.my_pipeline = my_pipeline.sort(['pos_rank'], ascending=False).iloc[:40]
    context.security_list = pipeline_output('my_pipeline').index[:7]

    update_universe(context.my_pipeline.index)
    pass
     
def my_assign_weights(context, data):
    """
    Assign weights to securities that we want to order.
    TBD: Weight according to optimal sharpe ratio
    """
    pass
 
def my_rebalance(context,data):    
    """
    Execute orders according to our schedule_function() timing. 
    """
    for stock in context.portfolio.positions.iterkeys():  
        if stock not in context.security_list:  
            order_target(stock, 0)  
    
    long_weight = 1.0 / float(len(context.security_list))  
    for long_stock in context.security_list:  
        if data.can_trade(long_stock):  
            order_target_percent(long_stock, long_weight)
    pass
 
def my_record_vars(context, data):
    """
    Plot variables at the end of each day.
    """
    long_count = 0
    short_count = 0
    cash = context.portfolio.cash
    portfolio_value = context.portfolio.portfolio_value

    for position in context.portfolio.positions.itervalues():
        if position.amount > 0:
            long_count += 1
        if position.amount < 0:
            short_count += 1

    # Plot the counts
    record(num_long=long_count, num_short=short_count, cash=cash, portfolio_value=portfolio_value)
    pass
 
def handle_data(context,data):
    """
    Called every minute.
    TBD: Delete?
    """
    pass
